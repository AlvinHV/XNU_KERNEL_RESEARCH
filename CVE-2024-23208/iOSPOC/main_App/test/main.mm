//
//  main.m
//  test
//
//  Created by 风沐云烟 on 2023/12/26.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

#include <arpa/inet.h>
#include <pthread/qos.h>
#include <sys/socket.h>
#include <pthread/pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/errno.h>
#include <sys/kern_control.h>
#include <sys/sys_domain.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <string.h>
#include <fcntl.h>

#define IPPROTO_TCP 6
#define FLOW_DIVERT_TLV_CTL_UNIT 10
#define FLOW_DIVERT_TLV_AGGREGATE_UNIT 26
#define SO_FLOW_DIVERT_TOKEN 0x1106
#define FLOW_DIVERT_TLV_SIGNING_ID 25

struct control {
  char     Type;
  uint32_t Length;
  uint32_t Unit;
}__attribute__((packed));

struct aggregate {
  char     Type;
  uint32_t Length;
  uint32_t Unit;
}__attribute__((packed));

struct signing_id {
    uint8_t  Type;
    uint32_t Length;
    uint32_t ID;
}__attribute__((packed));

struct flow_divert_create_packet {
  struct control control_unit;
  struct aggregate aggregate_unit;
  struct signing_id signing;
}__attribute__((packed));

int sock_fd[4];
uint32_t pcb_hash;
char *pause_mem = NULL;
void do_token() {
    sock_fd[0] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sock_fd[0] < 0) {
        perror("[do_token:socket]");
        exit(EXIT_FAILURE);
    }
    
    struct flow_divert_create_packet packet {
        .control_unit = {
            .Type   = FLOW_DIVERT_TLV_CTL_UNIT,
            .Length = htonl(4),
            .Unit   = htonl(0x0FFFFFFF),
        },
        .aggregate_unit = {
            .Type   = FLOW_DIVERT_TLV_AGGREGATE_UNIT,
            .Length = htonl(4),
            .Unit   = htonl(0),
        },
        .signing = {
            .Type   = FLOW_DIVERT_TLV_SIGNING_ID,
            .Length = htonl(4),
            .ID     = htonl(0),
        },
    };
    setsockopt(sock_fd[0], SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, &packet, sizeof(packet));
}

#define CTL_SIZE sizeof(struct sockaddr_ctl)
#define CTL_INFOSZ sizeof(struct ctl_info)
#define CONTROL_NAME "com.apple.flow-divert"

int sock_kctl[32];
void connect_kctl(int index) {
    sock_kctl[index] = socket(AF_SYSTEM,SOCK_DGRAM,SYSPROTO_CONTROL);
    if(sock_kctl[index] < 0) {
        perror("[connect_kctl:socket]");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_ctl target;
    target.sc_len     = CTL_SIZE;
    target.sc_family  = AF_SYSTEM;
    target.ss_sysaddr = AF_SYS_CONTROL;
    
    struct ctl_info info;
    memset(&info,0,CTL_INFOSZ);
    strlcpy(info.ctl_name,CONTROL_NAME,sizeof(info.ctl_name));
    if(ioctl(sock_kctl[index],CTLIOCGINFO,&info) == -1) {
        perror("[ioctl]");
        exit(EXIT_FAILURE);
    }
    target.sc_id      = info.ctl_id;
    target.sc_unit    = 0x0FFFFFFF;
    if (connect(sock_kctl[index], (struct sockaddr *)&target, CTL_SIZE) == -1) {
        perror("[connect_kctl:connect]");
        exit(EXIT_FAILURE);
    }

}

#define FLOW_DIVERT_PKT_GROUP_INIT 6
#define FLOW_DIVERT_TLV_TOKEN_KEY 17
struct flow_divert_packet_header {
    uint32_t             packet_type;
    uint32_t             conn_id;
}__attribute__((packed));

struct init_data {
    uint8_t  Type;
    uint32_t Length;
    char     to_BUF[4];
}__attribute__((packed));

struct result_data {
    uint8_t  Type;
    uint32_t Length;
    char     to_BUF[4];
}__attribute__((packed));


void group_init(int fd) {
    char *mem = (char*)malloc(0x200);
    bzero(mem,0x200);
    uint32_t length;
    
    struct flow_divert_packet_header *init_packet = (struct flow_divert_packet_header*)mem;
    
    init_packet->packet_type = FLOW_DIVERT_PKT_GROUP_INIT;
    init_packet->conn_id = htonl(0);
    struct init_data *key_size = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header));
    key_size->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    key_size->Length = htonl(4);
    *(uint32_t*)(key_size->to_BUF) = htonl(4);
    
    
    struct init_data *token = (struct init_data *)(mem + sizeof(struct flow_divert_packet_header) + 9);
    token->Type = FLOW_DIVERT_TLV_TOKEN_KEY;
    token->Length = htonl(4);
    *(uint32_t*)(token->to_BUF) = htonl(0xDEADBEEF);
    
    length = sizeof(struct flow_divert_packet_header) + 9 + 9;
    if(send(fd,mem,length,0) < 0) {
        perror("[group_init]");
        exit(EXIT_FAILURE);
    }
}

const char *SOCKET_PATH = NULL;

const char *Dir = NULL;
int recv_fd(int socket) {
    struct iovec iov[1];
    char dummy;
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置接收缓冲区
    iov[0].iov_base = &dummy;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    // 设置辅助数据
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    // 接收消息
    if (recvmsg(socket, &msg, 0) == -1) {
        perror("recvmsg");
        exit(EXIT_FAILURE);
    }

    struct cmsghdr *cmsg;
    int fd = -1;

    // 遍历辅助数据寻找文件描述符
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
            fd = *(int *)CMSG_DATA(cmsg);
            break;
        }
    }

    return fd;
}

void send_fd(int socket, int fd) {
    struct iovec iov[1];
    char dummy = '0'; // 用于填充辅助数据的字节  // Bytes used to fill in auxiliary data
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置辅助数据 // Set up auxiliary data
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    struct cmsghdr *cmsg;
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));

    // 设置辅助数据中的文件描述符 // Set the file descriptor in the auxiliary data
    *(int *)CMSG_DATA(cmsg) = fd;

    // 设置发送缓冲区  // Set the send buffer
    iov[0].iov_base = &dummy;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    // 发送消息 // Send a message
    if (sendmsg(socket, &msg, 0) == -1) {
        perror("sendmsg");
        exit(EXIT_FAILURE);
    }
}
//Unused
void RECV() {
    int sockfd, received_sockfd;
    struct sockaddr_un addr;
    
    // 创建 Unix 域套接字
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 连接到进程 A 创建的套接字
    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }
    
    // 接收套接字文件描述符
    received_sockfd = recv_fd(sockfd);
    printf("FD:%d\n",received_sockfd);
    char buf[8];
    read(received_sockfd,buf,8);
    write(1,buf,8);
    // 在进程 B 中使用接收到的套接字文件描述符
    // 进行套接字操作，例如发送和接收数据
    
    // 关闭套接字和连接
    close(received_sockfd);
    close(sockfd);
}

void SEND(void) {
    int sockfd, client_sockfd;
    struct sockaddr_un addr;

    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    
    // 设置套接字地址  // Set the socket address
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 绑定套接字到地址 // Bind the socket to the address
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    
    // 监听连接 // Monitor the connection
    if (listen(sockfd, 1) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }
    
    // 接受连接请求  // Accept the connection request
    printf("Process A is waiting for connection....\n");
    client_sockfd = accept(sockfd, NULL, NULL);
    if (client_sockfd == -1) {
        perror("accept");
        exit(EXIT_FAILURE);
    }
    printf("Process A receives a connection request\n");
    
    connect_kctl(0); // unit = 0xFFFF
    group_init(sock_kctl[0]); // init group for kctl_connect of flow-divert
    do_token();
    // 发送套接字文件描述符给进程 B  // Send a socket file descriptor to process B
    printf("myFD:%d\n",sock_fd[0]);
    send_fd(client_sockfd, sock_fd[0]);

    sleep(1);
    // 关闭连接 // Close the connection
    close(client_sockfd);
    close(sockfd);
    close(sock_fd[0]);
    close(sock_kctl[0]);
}

int main(int argc, char * argv[]) {
    
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
        
    }
    
    NSString *sharedFilePath = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.fmyy"].path;
    sharedFilePath = [sharedFilePath stringByAppendingPathComponent:@"SharedSocket.txt"];
    SOCKET_PATH = [sharedFilePath UTF8String];
    printf("delete: %d\n", remove(SOCKET_PATH));
    SEND();
    return 0;
    //return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
