//
//  main.m
//  test
//
//  Created by 风沐云烟 on 2023/12/26.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <fcntl.h>
const char *SOCKET_PATH = NULL;

const char *Dir = NULL;
int recv_fd(int socket) {
    struct iovec iov[1];
    char dummy;
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置接收缓冲区
    iov[0].iov_base = &dummy;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    // 设置辅助数据
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    // 接收消息
    if (recvmsg(socket, &msg, 0) == -1) {
        perror("recvmsg");
        exit(EXIT_FAILURE);
    }

    struct cmsghdr *cmsg;
    int fd = -1;

    // 遍历辅助数据寻找文件描述符
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
            fd = *(int *)CMSG_DATA(cmsg);
            break;
        }
    }

    return fd;
}

void send_fd(int socket, int fd) {
    struct iovec iov[1];
    char dummy = '0'; // 用于填充辅助数据的字节
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置辅助数据
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    struct cmsghdr *cmsg;
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));

    // 设置辅助数据中的文件描述符
    *(int *)CMSG_DATA(cmsg) = fd;

    // 设置发送缓冲区
    iov[0].iov_base = &dummy;
    iov[0].iov_len = 1;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    // 发送消息
    if (sendmsg(socket, &msg, 0) == -1) {
        perror("sendmsg");
        exit(EXIT_FAILURE);
    }
}

void RECV() {
    int sockfd, received_sockfd;
    struct sockaddr_un addr;
    
    // 创建 Unix 域套接字
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 连接到进程 A 创建的套接字
    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }
    
    // 接收套接字文件描述符
    received_sockfd = recv_fd(sockfd);
    printf("FD:%d\n",received_sockfd);
    char buf[8];
    read(received_sockfd,buf,8);
    write(1,buf,8);
    // 在进程 B 中使用接收到的套接字文件描述符
    // 进行套接字操作，例如发送和接收数据
    
    // 关闭套接字和连接
    close(received_sockfd);
    close(sockfd);
}

void SEND(void) {
    int sockfd, client_sockfd;
    struct sockaddr_un addr;

    int my_fd = socket(AF_INET,SOCK_STREAM,0);
    printf("my_FD:\t%d\n",my_fd);
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 绑定套接字到地址
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
    
    
    // 监听连接
    if (listen(sockfd, 1) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }
    
    // 接受连接请求
    printf("进程 A 正在等待连接...\n");
    client_sockfd = accept(sockfd, NULL, NULL);
    if (client_sockfd == -1) {
        perror("accept");
        exit(EXIT_FAILURE);
    }
    printf("进程 A 收到连接请求\n");
    
    // 发送套接字文件描述符给进程 B
    printf("myFD:%d\n",my_fd);
    send_fd(client_sockfd, my_fd);
    
    sleep(1);
    // 关闭连接
    close(client_sockfd);
    close(sockfd);
    
}

int main(int argc, char * argv[]) {

    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    
    NSString *sharedFilePath = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.fmyy"].path;
    sharedFilePath = [sharedFilePath stringByAppendingPathComponent:@"SharedSocket.txt"];
    remove(SOCKET_PATH);
    SOCKET_PATH = [sharedFilePath UTF8String];
    
    SEND();
    return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
